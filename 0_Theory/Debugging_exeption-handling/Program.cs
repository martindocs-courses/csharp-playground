/* Navigation Notes
    
    Testing, Debugging & Exeptions                  : line 27
    Exeptions                                       : line 49 
    Exception handling process                      : line 95
    Compiler-generated exceptions                   : line 122
        Example 1                                   : line 135
        Example 2                                   : line 157    
    Exception properties                            : line 194
    Catch multiple exceptions in a code block       : line 278
    Catch separate exceptions types in a code block : line 337   
    Throw exception                                 : line 368
        Create an exception object                  : line 374
        Configure and throw customized exceptions   : line 391
        When to throw an exception                  : line 416
        Re-throwing exceptions                      : line 465
        Things to avoid when throwing exceptions    : line 573  
    
        Example 3                                   : line 583
        Example 4                                   : line 675

    Tips:
    - press ctr + g in Visual Studio to jump to specific line.
*/

/*
    TESTING:
    Software testing categories can be organized under the types of testing, the approaches to testing, or a combination of both. One way to categorize the types of testing is to split testing into Functional and Nonfunctional testing. The functional and nonfunctional categories each include subcategories of testing. For example, functional and nonfunctional testing could be divided into the following subcategories:

    * Functional testing - Unit testing - Integration testing - System testing - Acceptance testing
    * Nonfunctional testing - Security testing - Performance testing - Usability testing - Compatibility testing
    
    DEBUGGING:
    Code debugging is a process that developers use to isolate an issue and identify one or more ways to fix it. The issue could be related to either code logic or an exception. Either way, you work on debugging your code when it isn't working the way you want it to. Generally speaking, the term debugging is reserved for runtime issues that aren't easy to isolate. 

    EXEPTIONS:
     In C# development, the errors that occur while the application is running are referred to as exceptions. The term "exception handling" refers to the process that a developer uses to manage those runtime exceptions within their code. Errors that occur during the build process are referred to as errors, and aren't part of the exception handling process. Exceptions can be generated by the common language runtime (CLR), by .NET or third-party libraries, or by application code.

    * An exception gets created at runtime when your code produces an error.
    * The exception can be treated like a variable that has some extra capabilities.
    * You can write code that accesses the exception and takes corrective action.
    * Exceptions are used in C# to propagate errors at runtime, and are represented by classes derived from the Exception class.
    * Exceptions are thrown by code that encounters an error and caught by code that can correct the error.
    * When an exception is caught, code can access its contents and take corrective action to mitigate the error.
    * The .NET runtime generates exceptions when it detects an error and the exception contains information about the type of error that occurred.
*/


/* EXEPTIONS HANDLING */

/*
    Common scenarios that require exception handling include:

    * User input: Exceptions can occur when code processes user input. For example, exceptions occur when the input value is in the wrong format or out of range.

    * Data processing and computations: Exceptions can occur when code performs data calculations or conversions. For example, exceptions occur when code attempts to divide by zero, cast to an unsupported type, or assign a value that's out of range.

    * File input/output operations: Exceptions can occur when code reads from or writes to a file. For example, exceptions occur when the file doesn't exist, the program doesn't have permission to access the file, or the file is in use by another process.

    * Database operations: Exceptions can occur when code interacts with a database. For example, exceptions occur when the database connection is lost, a syntax error occurs in a SQL statement, or a constraint violation occurs.

    * Network communication: Exceptions can occur when code communicates over a network. For example, exceptions occur when the network connection is lost, a timeout occurs, or the remote server returns an error.

    * Other external resources: Exceptions can occur when code communicates with other external resources. Web Services, REST APIs, or third-party libraries, can throw exceptions for various reasons. For example, exceptions occur due to network connections issues, malformed data, etc. 
    
    * The exception objects caught by your C# application are instances of an exception class. Generally speaking, your code will catch one of the following:

    - An exception object that's an instance of the System.Exception base class.
    - An exception object that's an instance of an exception type that inherits from the base class. For example, an instance of the InvalidCastException class. 
*/

// Exception handling in C# is implemented by using the try, catch, and finally keywords.
/*
    try
    {   
       // try code block - code that may generate an exception
    }
    catch
    {   
       // catch code block - code to handle an exception
    }
    finally
    {   
       // finally code block - code to clean up resources
    } 


    The try code block contains the guarded code that may cause an exception. If the code within a try block causes an exception, the exception is handled by a corresponding catch block.

    The catch code block contains the code that's executed when an exception is caught. The catch block can handle the exception, log it, or ignore it. A catch block can be configured to execute when any exception type occurs, or only when a specific type of exception occurs.

    The finally code block contains code that executes whether an exception occurs or not. The finally block is often used to clean up any resources that are allocated in a try block. For example, ensuring that a variable has the correct or required value assigned to it.
*/

/* EXCEPTION HANDLING PROCESS */
Console.WriteLine($"Exception handling process");
Console.WriteLine($"--------------------------");

int[] numbers = { 1, 2, 3, 4 };
try
{
    // Step 1: code execution begins
    try
    {
        // Step 2: an exception occurs here
        Console.WriteLine(numbers[5]);

    }
    finally
    {
        // Step 4: the system executes the finally code block associated with the try statement where the exception occurred
        Console.WriteLine("This first before error");
    }

}
catch // Step 3: the system finds a catch clause that can handle the exception
{
    // Step 5: the system transfers control to the first line of the catch code block
    Console.WriteLine("error");
}

/* COMPILER-GENERATED EXCEPTIONS*/
Console.WriteLine($"\nCompiler-generated exceptions");
Console.WriteLine($"-----------------------------");
/*
    - ArrayTypeMismatchException: Thrown when an array can't store a given element because the actual type of the element is incompatible with the actual type of the array.
    - DivideByZeroException: Thrown when an attempt is made to divide an integral value by zero. ividing a floating-point value by zero doesn't throw an exception; it results in positive infinity, negative infinity, or not a number (NaN)
    - FormatException: Thrown when the format of an argument is invalid.
    - IndexOutOfRangeException: Thrown when an attempt is made to index an array when the index is less than zero or outside the bounds of the array.
    - InvalidCastException: Thrown when an explicit conversion from a base type to an interface or to a derived type fails at runtime.
    - NullReferenceException: Thrown when an attempt is made to reference an object whose value is null.
    - OverflowException: Thrown when an arithmetic operation in a checked context overflows. 
*/

// EXAMPLE 1    
double float1 = 3000.0;
double float2 = 0.0;
int number1 = 3000;
int number2 = 0;

try
{
    Console.WriteLine(float1 / float2); // wont cause an error
    Console.WriteLine(number1 / number2); // will cause an error

}
catch
{
    Console.WriteLine("An exception has been caught.");
}
finally
{
    Console.WriteLine("Exit program"); 
}

Console.WriteLine();
// EXAMPLE 2
try
{
    Process1(); 
}
// since the exception is caught inside Process1, the catch code block in the top-level statements is not executed.
catch
{
    Console.WriteLine("An exception has occurred");
}

Console.WriteLine("Exit program");

// the Process1 method has been updated to use the try-catch pattern. The WriteMessage method is called in the try code block, which enables Process1 to catch the exception before it's caught by the catch clause in the top-level statements.
static void Process1()
{
    try
    {
        WriteMessage();        
    }
    catch
    {
        Console.WriteLine("Exception caught in Process1");
    }
}

static void WriteMessage()
{
    double float1 = 3000.0;
    double float2 = 0.0;
    int number1 = 3000;
    int number2 = 0;

    Console.WriteLine(float1 / float2);
    Console.WriteLine(number1 / number2);
}

/* EXCEPTION PROPERTIES */
Console.WriteLine($"\nException properties");
Console.WriteLine($"--------------------");
/*
    System.Exception is the base class that all derived exception types inherit from. Each exception type inherits from the base class through a specific class hierarchy. For example, the class hierarchy for the InvalidCastException is as follows:

        Output:

        Copy
        Object
            Exception
                SystemException
                    InvalidCastException    

    Most of the exception classes that inherit from Exception don't add any additional functionality; they simply inherit from Exception.

    Here are the properties of the Exception class:

    * Data: The Data property holds arbitrary data in key-value pairs.
    * HelpLink: The HelpLink property can be used to hold a URL (or URN) to a help file that provides extensive information about the cause of an exception.
    * HResult: The HResult property can be used to access to a coded numerical value that's assigned to a specific exception.
    * InnerException: The InnerException property can be used to create and preserve a series of exceptions during exception handling.
    * Message: The Message property provides details about the cause of an exception.
    * Source: The Source property can be used to access the name of the application or the object that causes the error.
    * StackTrace: The StackTrace property contains a stack trace that can be used to determine where an error occurred.
    * TargetSite: The TargetSite property can be used to get the method that throws the current exception.
*/

try
{
    Process2();
}
catch
{
    // 2. new exception type is caught by the catch clause in the top-level statements rather than inside the Process2 method.
    Console.WriteLine("An exception has occurred");
}

Console.WriteLine("Exit program");

static void Process2()
{
    try
    {
        WriteMessage2();
    }
    //catch(Exception err)

    // 1. Catch specific exception type. Your Process2 method will only catch exceptions of the specific type that it's prepared to handle.

    // 3. The catch block in Process2 is not executed. This is the behavior that you wanted. Only catch the exceptions that your code is prepared to handle.
    catch (DivideByZeroException err)
    {
        // Access the properties of an exception object
        //Console.WriteLine($"Exception caught in Process2: {err}");

        Console.WriteLine($"Exception caught in Process2: {err.Message}");

        /*
         In general, you should only catch the exceptions that your code knows how to recover from. Therefore, your catch clause should specify an object argument that's derived from System.Exception. The exception type should be as specific as possible. This helps to avoid catching exceptions that your exception handler isn't able to resolve.
         */
    }
}

static void WriteMessage2()
{
    double float1 = 3000.0;
    double float2 = 0.0;
    int number1 = 3000;
    int number2 = 0;
    byte smallNumber;

    Console.WriteLine(float1 / float2);
    //Console.WriteLine(number1 / number2);

    /*
     'checked' context, the conversion succeeds if the source value is within the range of the destination type. Otherwise, an OverflowException is thrown.
     */
    checked
    {
        smallNumber = (byte)number1;
    }
}

/* CATCH MULTIPLE EXCEPTIONS IN A CODE BLOCK */
Console.WriteLine($"\nCatch multiple exceptions in a code block");
Console.WriteLine($"------------------------------------------");

Process3();
//try
//{
//    Process3();
//}
//catch
//{   
//    Console.WriteLine("An exception has occurred");
//}

Console.WriteLine("Exit program");

static void Process3()
{
    // If we have try-catch here, then the secound exception would not be executed
    // 1. exceptions should be caught as close to where they occur as possible.

    //try
    //{
    //    WriteMessage3();
    //}catch (DivideByZeroException err)
    //{  
    //    Console.WriteLine($"Exception caught in Process3: {err.Message}");
    //}
   
    WriteMessage3();
}

static void WriteMessage3()
{
    double float1 = 3000.0;
    double float2 = 0.0;
    int number1 = 3000;
    int number2 = 0;
    byte smallNumber;

    // 2. with this in mind we try-catch here
    try{
        Console.WriteLine(float1 / float2);
        Console.WriteLine(number1 / number2);
    }catch(DivideByZeroException err){
        Console.WriteLine($"Exception caught in Process3: {err.Message}");
    }

    checked
    {
        // 3. seme goes to overflow ex 
        try{
            smallNumber = (byte)number1;        
        }catch(OverflowException err){        
            Console.WriteLine($"Exception caught in WriteMessage3: {err.Message}");
        }
    }
}

/* CATCH SEPARATE EXCEPTIONS TYPES IN A CODE BLOCK */
Console.WriteLine($"\nCatch separate exception types in a code block");
Console.WriteLine($"-----------------------------------------------");

// inputValues is used to store numeric values entered by a user
string[] inputValues = new string[] { "three", "9999999999", "0", "2" };

foreach (string inputValue in inputValues)
{
    int numValue = 0;

    // Depending on the value entered, different exception types may occur.
    try
    {
        numValue = int.Parse(inputValue);
    }
    catch (FormatException)
    {
        Console.WriteLine("Invalid readResult. Please enter a valid number.");
    }
    catch (OverflowException)
    {
        Console.WriteLine("The number you entered is too large or too small.");
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
}


/* THROW EXCEPTIONS */

/*
    Exception objects that describe an error are created and then thrown with the throw keyword. When an exception is thrown by your code, the runtime searches for the nearest catch clause that can handle the exception. 
*/

// CREATE AN EXCEPTION OBJECT

/*
    Here are some common exception types that you might use when creating an exception:

    * ArgumentException or ArgumentNullException: Use these exception types when a method or constructor is called with an invalid argument value or null reference.
    * InvalidOperationException: Use this exception type when the operating conditions of a method don't support the successful completion of a particular method call.
    * NotSupportedException: Use this exception type when an operation or feature is not supported.
    * IOException: Use this exception type when an input/output operation fails.
    * FormatException: Use this exception type when the format of a string or data is incorrect.
    
    The new keyword is used to create an instance of an exception. For example, you can create an instance of the ArgumentException exception type as follows:

    ArgumentException invalidArgumentException = new ArgumentException(); 
 
*/

// CONFIGURE AND THROW CUSTOMIZED EXCEPTIONS

/*
    The process for throwing an exception object involves creating an instance of an exception-derived class, optionally configuring properties of the exception, and then throwing the object by using the throw keyword. 
*/

/*
     Exception with custom message. The Message property of an exception is readonly. Therefore, a custom Message property must be set when instantiating the object:
     ...
        ArgumentException invalidArgumentException = new ArgumentException("ArgumentException: The 'GraphData' method received data outside the expected range.");

        throw invalidArgumentException;
    
    An exception object can also be created directly within a throw statement:
    ...
        throw new FormatException("FormatException: Calculations in process XYZ have been cancelled due to invalid data format.");
*/

/*
    Some considerations to keep in mind when throwing an exception include:

    * The Message property should explain the reason for the exception. However, information that's sensitive, or that represents a security concern shouldn't be put in the message text.
    * The StackTrace property is often used to track the origin of the exception. This string property contains the name of the methods on the current call stack, together with the file name and line number in each method that's associated with the exception. A StackTrace object is created automatically by the common language runtime (CLR) from the point of the throw statement. Exceptions must be thrown from the point where the stack trace should begin. 
*/

// WHEN TO THROW AN EXCEPTION
Console.WriteLine($"\nWhen to throw an exception");
Console.WriteLine($"---------------------------");
/*
    Methods should throw an exception whenever they can't complete their intended purpose. The exception thrown should be based on the most specific exception available that fits the error conditions.
 */

string[][] userEnteredValues = new string[][]
{
        new string[] { "1", "two", "3"},
        new string[] { "0", "1", "2"}
};

foreach (string[] userEntries in userEnteredValues)
{
    try
    {
        BusinessProcess1(userEntries);
    }
    catch (Exception ex)
    {
        if (ex.StackTrace.Contains("BusinessProcess1") && (ex is FormatException))
        {
            Console.WriteLine(ex.Message);
        }
    }
}

static void BusinessProcess1(string[] userEntries)
{
    int valueEntered;

    foreach (string userValue in userEntries)
    {
        try
        {
            valueEntered = int.Parse(userValue);

            // completes required calculations based on userValue
            // ...
        }
        catch (FormatException)
        {
            FormatException invalidFormatException = new FormatException("FormatException: User input values in 'BusinessProcess1' must be valid integers");
            throw invalidFormatException;
        }
    }
}

// RE-THROWING EXCEPTIONS 
Console.WriteLine($"\nRe-throwing exceptions");
Console.WriteLine($"------------------------");
/*
    In addition to throwing a new exception, throw can be used re-throw an exception from inside a catch code block.
    ...
    catch (Exception ex)
    {
        // handle or partially handle the exception
        // ...

        // re-throw the original exception object for further handling down the call stack
        throw;
    }

    When you re-throw an exception, the original exception object is used, so you don't lose any information about the exception. If you want to create a new exception object that wraps the original exception, you can pass the original exception as an argument to the constructor of a new exception object:
    ...
    catch (Exception ex)
    {
        // handle or partially handle the exception
        // ...

        // create a new exception object that wraps the original exception
        throw new ApplicationException("An error occurred", ex);
    }
*/

try
{
    OperatingProcedure2();
}
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
    Console.WriteLine("Exiting application.");
}

static void OperatingProcedure2()
{
    string[][] userEnteredValues = new string[][]
    {
        new string[] { "1", "two", "3"},
        new string[] { "0", "1", "2"}
    };

    foreach (string[] userEntries in userEnteredValues)
    {
        try
        {
            BusinessProcess2(userEntries);
        }
        catch (Exception ex)
        {
            if (ex.StackTrace.Contains("BusinessProcess2"))
            {
                if (ex is FormatException)
                {
                    Console.WriteLine(ex.Message);
                    Console.WriteLine("Corrective action taken in OperatingProcedure2");
                }
                else if (ex is DivideByZeroException)
                {
                    Console.WriteLine(ex.Message);
                    Console.WriteLine("Partial correction in OperatingProcedure2 - further action required");

                    // re-throw the original exception
                    throw;
                }
                else
                {
                    // create a new exception object that wraps the original exception
                    throw new ApplicationException("An error occurred - ", ex);
                }
            }
        }

    }
}

static void BusinessProcess2(string[] userEntries)
{
    int valueEntered;

    foreach (string userValue in userEntries)
    {
        try
        {
            valueEntered = int.Parse(userValue);

            checked
            {
                int calculatedValue = 4 / valueEntered;
            }
        }
        catch (FormatException)
        {
            FormatException invalidFormatException = new FormatException("FormatException: User input values in 'BusinessProcess2' must be valid integers");
            throw invalidFormatException;
        }
        catch (DivideByZeroException)
        {
            DivideByZeroException unexpectedDivideByZeroException = new DivideByZeroException("DivideByZeroException: Calculation in 'BusinessProcess2' encountered an unexpected divide by zero");
            throw unexpectedDivideByZeroException;

        }
    }
}

// THINGS TO AVOID WHEN THROWING EXCEPTIONS  

/*
    Practices to avoid when throwing exceptions:
    * Don't use exceptions to change the flow of a program as part of ordinary execution. Use exceptions to report and handle error conditions.
    * Exceptions shouldn't be returned as a return value or parameter instead of being thrown.
    * Don't throw System.Exception, System.SystemException, System.NullReferenceException, or System.IndexOutOfRangeException intentionally from your own source code.
    * Don't create exceptions that can be thrown in debug mode but not release mode. To identify runtime errors during the development phase, use Debug.Assert instead. 
 */

/* EXAMPLE 3 */
Console.WriteLine($"\nExample 3");
Console.WriteLine($"-----------");

// Prompt the user for the lower and upper bounds
Console.Write("Enter the lower bound: ");
int lowerBound = int.Parse(Console.ReadLine());

Console.Write("Enter the upper bound: ");
int upperBound = int.Parse(Console.ReadLine());

decimal averageValue = 0;

// 1. Whenever possible, exceptions should be caught at the call stack level where they can be handled. 

// 3. Continuing to catch the exception requires a loop. Since you want to call the AverageOfEvenNumbers method at least once, a do loop should be used.

bool exit = false;

do
{
    try
    {

        // Calculate the sum of the even numbers between the bounds
        averageValue = AverageOfEvenNumbers(lowerBound, upperBound);

        // Display the value returned by AverageOfEvenNumbers in the console
        Console.WriteLine($"The average of even numbers between {lowerBound} and {upperBound} is {averageValue}.");

        exit = true;
    }
    catch (ArgumentOutOfRangeException ex)
    {
        /*
            2. To handle this exception, your code needs to do the following:
            * Explain the issue to the user.
            * Obtain a new value for upperBound.
            * Call AverageOfEvenNumbers using the new upperBound.
            * Continue to catch the exception if the new upperBound provided is still less than or equal to lowerBound.     
         */
        Console.WriteLine("An error has occurred.");
        Console.WriteLine(ex.Message);
        Console.WriteLine($"The upper bound must be greater than: {lowerBound}");

        //  Give the user needs to exit the loop rather than enter a value
        Console.Write($"Enter a new upper bound (or enter Exit to quit): ");
        string? userResponse = Console.ReadLine();

        if (userResponse.ToLower().Contains("exit"))
        {
            exit = true;
        }
        else
        {
            exit = false;
            upperBound = int.Parse(userResponse);
        }
    }
} while (exit == false);

// Wait for user input
Console.ReadLine();

static decimal AverageOfEvenNumbers(int lowerBound, int upperBound)
{
    if (lowerBound >= upperBound)
    {

        throw new ArgumentOutOfRangeException("upperBound", "ArgumentOutOfRangeException: upper bound must be greater than lower bound.");
    }

    int sum = 0;
    int count = 0;
    decimal average = 0;



    for (int i = lowerBound; i <= upperBound; i++)
    {
        if (i % 2 == 0)
        {
            sum += i;
            count++;
        }
    }

    average = (decimal)sum / count;

    return average;
}

/* EXAMPLE 4 */

// Replace console log with exceptions
string[][] userEnteredValues = new string[][]
{
            new string[] { "1", "2", "3"},
            new string[] { "1", "two", "3"},
            new string[] { "0", "1", "2"}
};

//string overallStatusMessage = "";

//overallStatusMessage = Workflow1(userEnteredValues);

try
{
    Workflow1(userEnteredValues);
    Console.WriteLine("'Workflow1' completed successfully.");
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("An error occurred during 'Workflow1'.");
    Console.WriteLine(ex.Message);
}

//if (overallStatusMessage == "operating procedure complete")
//{
//    Console.WriteLine("'Workflow1' completed successfully.");
//}
//else
//{
//    Console.WriteLine("An error occurred during 'Workflow1'.");
//    Console.WriteLine(overallStatusMessage);
//}

static void Workflow1(string[][] userEnteredValues)
{
    //string operationStatusMessage = "good";
    //string processStatusMessage = "";

    foreach (string[] userEntries in userEnteredValues)
    {
        //processStatusMessage = Process1(userEntries);

        try
        {
            Process1(userEntries);
            Console.WriteLine("'Process1' completed successfully.");
            Console.WriteLine();
        }
        catch (FormatException ex)
        {
            Console.WriteLine("'Process1' encountered an issue, process aborted.");
            Console.WriteLine(ex.Message);
            Console.WriteLine();
        }

        //if (processStatusMessage == "process complete")
        //{
        //    Console.WriteLine("'Process1' completed successfully.");
        //    Console.WriteLine();
        //}
        //else
        //{
        //    Console.WriteLine("'Process1' encountered an issue, process aborted.");
        //    Console.WriteLine(processStatusMessage);
        //    Console.WriteLine();
        //    operationStatusMessage = processStatusMessage;
        //}
    }

    //if (operationStatusMessage == "good")
    //{
    //    operationStatusMessage = "operating procedure complete";
    //}

    //return operationStatusMessage;
}

static void Process1(String[] userEntries)
{
    //string processStatus = "clean";
    //string returnMessage = "";
    int valueEntered;

    foreach (string userValue in userEntries)
    {

        bool integerFormat = int.TryParse(userValue, out valueEntered);

        if (integerFormat == true)
        {
            if (valueEntered != 0)
            {

                checked
                {
                    int calculatedValue = 4 / valueEntered;
                }

            }
            else
            {
                throw new DivideByZeroException("User input values must be non-zero values.");
            }
        }
        else
        {
            throw new FormatException("Invalid data. User input values must be valid integers.");
        }


        //if (integerFormat == true)
        //{
        //    if (valueEntered != 0)
        //    {
        //        checked
        //        {
        //            int calculatedValue = 4 / valueEntered;
        //        }
        //    }
        //    else
        //    {
        //        returnMessage = "Invalid data. User input values must be non-zero values.";
        //        processStatus = "error";
        //    }
        //}
        //else
        //{
        //    returnMessage = "Invalid data. User input values must be valid integers.";
        //    processStatus = "error";
        //}
    }

    //if (processStatus == "clean")
    //{
    //    returnMessage = "process complete";
    //}

    //return returnMessage;
}