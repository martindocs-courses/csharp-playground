/* Navigation Notes
    
    Testing, Debugging & Exeptions                  : line 19
    Exeptions                                       : line 41 
    Exception handling process                      : line 87
    Compiler-generated exceptions                   : line 114
        Example 1                                   : line 127
        Example 2                                   : line 149
    
    Exception properties                            : line 186
    Catch multiple exceptions in a code block       : line 270
    Catch separate exceptions types in a code block : line 329   

    Tips:
    - press ctr + g in Visual Studio to jump to specific line.
*/

/*
    TESTING:
    Software testing categories can be organized under the types of testing, the approaches to testing, or a combination of both. One way to categorize the types of testing is to split testing into Functional and Nonfunctional testing. The functional and nonfunctional categories each include subcategories of testing. For example, functional and nonfunctional testing could be divided into the following subcategories:

    * Functional testing - Unit testing - Integration testing - System testing - Acceptance testing
    * Nonfunctional testing - Security testing - Performance testing - Usability testing - Compatibility testing
    
    DEBUGGING:
    Code debugging is a process that developers use to isolate an issue and identify one or more ways to fix it. The issue could be related to either code logic or an exception. Either way, you work on debugging your code when it isn't working the way you want it to. Generally speaking, the term debugging is reserved for runtime issues that aren't easy to isolate. 

    EXEPTIONS:
     In C# development, the errors that occur while the application is running are referred to as exceptions. The term "exception handling" refers to the process that a developer uses to manage those runtime exceptions within their code. Errors that occur during the build process are referred to as errors, and aren't part of the exception handling process. Exceptions can be generated by the common language runtime (CLR), by .NET or third-party libraries, or by application code.

    * An exception gets created at runtime when your code produces an error.
    * The exception can be treated like a variable that has some extra capabilities.
    * You can write code that accesses the exception and takes corrective action.
    * Exceptions are used in C# to propagate errors at runtime, and are represented by classes derived from the Exception class.
    * Exceptions are thrown by code that encounters an error and caught by code that can correct the error.
    * When an exception is caught, code can access its contents and take corrective action to mitigate the error.
    * The .NET runtime generates exceptions when it detects an error and the exception contains information about the type of error that occurred.
*/


/* EXEPTIONS HANDLING */

/*
    Common scenarios that require exception handling include:

    * User input: Exceptions can occur when code processes user input. For example, exceptions occur when the input value is in the wrong format or out of range.

    * Data processing and computations: Exceptions can occur when code performs data calculations or conversions. For example, exceptions occur when code attempts to divide by zero, cast to an unsupported type, or assign a value that's out of range.

    * File input/output operations: Exceptions can occur when code reads from or writes to a file. For example, exceptions occur when the file doesn't exist, the program doesn't have permission to access the file, or the file is in use by another process.

    * Database operations: Exceptions can occur when code interacts with a database. For example, exceptions occur when the database connection is lost, a syntax error occurs in a SQL statement, or a constraint violation occurs.

    * Network communication: Exceptions can occur when code communicates over a network. For example, exceptions occur when the network connection is lost, a timeout occurs, or the remote server returns an error.

    * Other external resources: Exceptions can occur when code communicates with other external resources. Web Services, REST APIs, or third-party libraries, can throw exceptions for various reasons. For example, exceptions occur due to network connections issues, malformed data, etc. 
    
    * The exception objects caught by your C# application are instances of an exception class. Generally speaking, your code will catch one of the following:

    - An exception object that's an instance of the System.Exception base class.
    - An exception object that's an instance of an exception type that inherits from the base class. For example, an instance of the InvalidCastException class. 
*/

// Exception handling in C# is implemented by using the try, catch, and finally keywords.
/*
    try
    {   
       // try code block - code that may generate an exception
    }
    catch
    {   
       // catch code block - code to handle an exception
    }
    finally
    {   
       // finally code block - code to clean up resources
    } 


    The try code block contains the guarded code that may cause an exception. If the code within a try block causes an exception, the exception is handled by a corresponding catch block.

    The catch code block contains the code that's executed when an exception is caught. The catch block can handle the exception, log it, or ignore it. A catch block can be configured to execute when any exception type occurs, or only when a specific type of exception occurs.

    The finally code block contains code that executes whether an exception occurs or not. The finally block is often used to clean up any resources that are allocated in a try block. For example, ensuring that a variable has the correct or required value assigned to it.
*/

// EXCEPTION HANDLING PROCESS
Console.WriteLine($"Exception handling process");
Console.WriteLine($"--------------------------");

int[] numbers = { 1, 2, 3, 4 };
try
{
    // Step 1: code execution begins
    try
    {
        // Step 2: an exception occurs here
        Console.WriteLine(numbers[5]);

    }
    finally
    {
        // Step 4: the system executes the finally code block associated with the try statement where the exception occurred
        Console.WriteLine("This first before error");
    }

}
catch // Step 3: the system finds a catch clause that can handle the exception
{
    // Step 5: the system transfers control to the first line of the catch code block
    Console.WriteLine("error");
}

// COMPILER-GENERATED EXCEPTIONS
Console.WriteLine($"\nCompiler-generated exceptions");
Console.WriteLine($"-----------------------------");
/*
    - ArrayTypeMismatchException: Thrown when an array can't store a given element because the actual type of the element is incompatible with the actual type of the array.
    - DivideByZeroException: Thrown when an attempt is made to divide an integral value by zero. ividing a floating-point value by zero doesn't throw an exception; it results in positive infinity, negative infinity, or not a number (NaN)
    - FormatException: Thrown when the format of an argument is invalid.
    - IndexOutOfRangeException: Thrown when an attempt is made to index an array when the index is less than zero or outside the bounds of the array.
    - InvalidCastException: Thrown when an explicit conversion from a base type to an interface or to a derived type fails at runtime.
    - NullReferenceException: Thrown when an attempt is made to reference an object whose value is null.
    - OverflowException: Thrown when an arithmetic operation in a checked context overflows. 
*/

// EXAMPLE 1    
double float1 = 3000.0;
double float2 = 0.0;
int number1 = 3000;
int number2 = 0;

try
{
    Console.WriteLine(float1 / float2); // wont cause an error
    Console.WriteLine(number1 / number2); // will cause an error

}
catch
{
    Console.WriteLine("An exception has been caught.");
}
finally
{
    Console.WriteLine("Exit program"); 
}

Console.WriteLine();
// EXAMPLE 2
try
{
    Process1(); 
}
// since the exception is caught inside Process1, the catch code block in the top-level statements is not executed.
catch
{
    Console.WriteLine("An exception has occurred");
}

Console.WriteLine("Exit program");

// the Process1 method has been updated to use the try-catch pattern. The WriteMessage method is called in the try code block, which enables Process1 to catch the exception before it's caught by the catch clause in the top-level statements.
static void Process1()
{
    try
    {
        WriteMessage();        
    }
    catch
    {
        Console.WriteLine("Exception caught in Process1");
    }
}

static void WriteMessage()
{
    double float1 = 3000.0;
    double float2 = 0.0;
    int number1 = 3000;
    int number2 = 0;

    Console.WriteLine(float1 / float2);
    Console.WriteLine(number1 / number2);
}

// EXCEPTION PROPERTIES
Console.WriteLine($"\nException properties");
Console.WriteLine($"--------------------");
/*
    System.Exception is the base class that all derived exception types inherit from. Each exception type inherits from the base class through a specific class hierarchy. For example, the class hierarchy for the InvalidCastException is as follows:

        Output:

        Copy
        Object
            Exception
                SystemException
                    InvalidCastException    

    Most of the exception classes that inherit from Exception don't add any additional functionality; they simply inherit from Exception.

    Here are the properties of the Exception class:

    * Data: The Data property holds arbitrary data in key-value pairs.
    * HelpLink: The HelpLink property can be used to hold a URL (or URN) to a help file that provides extensive information about the cause of an exception.
    * HResult: The HResult property can be used to access to a coded numerical value that's assigned to a specific exception.
    * InnerException: The InnerException property can be used to create and preserve a series of exceptions during exception handling.
    * Message: The Message property provides details about the cause of an exception.
    * Source: The Source property can be used to access the name of the application or the object that causes the error.
    * StackTrace: The StackTrace property contains a stack trace that can be used to determine where an error occurred.
    * TargetSite: The TargetSite property can be used to get the method that throws the current exception.
*/

try
{
    Process2();
}
catch
{
    // 2. new exception type is caught by the catch clause in the top-level statements rather than inside the Process2 method.
    Console.WriteLine("An exception has occurred");
}

Console.WriteLine("Exit program");

static void Process2()
{
    try
    {
        WriteMessage2();
    }
    //catch(Exception err)

    // 1. Catch specific exception type. Your Process2 method will only catch exceptions of the specific type that it's prepared to handle.

    // 3. The catch block in Process2 is not executed. This is the behavior that you wanted. Only catch the exceptions that your code is prepared to handle.
    catch (DivideByZeroException err)
    {
        // Access the properties of an exception object
        //Console.WriteLine($"Exception caught in Process2: {err}");

        Console.WriteLine($"Exception caught in Process2: {err.Message}");

        /*
         In general, you should only catch the exceptions that your code knows how to recover from. Therefore, your catch clause should specify an object argument that's derived from System.Exception. The exception type should be as specific as possible. This helps to avoid catching exceptions that your exception handler isn't able to resolve.
         */
    }
}

static void WriteMessage2()
{
    double float1 = 3000.0;
    double float2 = 0.0;
    int number1 = 3000;
    int number2 = 0;
    byte smallNumber;

    Console.WriteLine(float1 / float2);
    //Console.WriteLine(number1 / number2);

    /*
     'checked' context, the conversion succeeds if the source value is within the range of the destination type. Otherwise, an OverflowException is thrown.
     */
    checked
    {
        smallNumber = (byte)number1;
    }
}

// CATCH MULTIPLE EXCEPTIONS IN A CODE BLOCK 
Console.WriteLine($"\nCatch multiple exceptions in a code block");
Console.WriteLine($"------------------------------------------");

Process3();
//try
//{
//    Process3();
//}
//catch
//{   
//    Console.WriteLine("An exception has occurred");
//}

Console.WriteLine("Exit program");

static void Process3()
{
    // If we have try-catch here, then the secound exception would not be executed
    // 1. exceptions should be caught as close to where they occur as possible.

    //try
    //{
    //    WriteMessage3();
    //}catch (DivideByZeroException err)
    //{  
    //    Console.WriteLine($"Exception caught in Process3: {err.Message}");
    //}
   
    WriteMessage3();
}

static void WriteMessage3()
{
    double float1 = 3000.0;
    double float2 = 0.0;
    int number1 = 3000;
    int number2 = 0;
    byte smallNumber;

    // 2. with this in mind we try-catch here
    try{
        Console.WriteLine(float1 / float2);
        Console.WriteLine(number1 / number2);
    }catch(DivideByZeroException err){
        Console.WriteLine($"Exception caught in Process3: {err.Message}");
    }

    checked
    {
        // 3. seme goes to overflow ex 
        try{
            smallNumber = (byte)number1;        
        }catch(OverflowException err){        
            Console.WriteLine($"Exception caught in WriteMessage3: {err.Message}");
        }
    }
}

// CATCH SEPARATE EXCEPTIONS TYPES IN A CODE BLOCK
Console.WriteLine($"\nCatch separate exception types in a code block");
Console.WriteLine($"-----------------------------------------------");

// inputValues is used to store numeric values entered by a user
string[] inputValues = new string[] { "three", "9999999999", "0", "2" };

foreach (string inputValue in inputValues)
{
    int numValue = 0;

    // Depending on the value entered, different exception types may occur.
    try
    {
        numValue = int.Parse(inputValue);
    }
    catch (FormatException)
    {
        Console.WriteLine("Invalid readResult. Please enter a valid number.");
    }
    catch (OverflowException)
    {
        Console.WriteLine("The number you entered is too large or too small.");
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
}

